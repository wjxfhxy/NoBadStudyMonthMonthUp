# 《架构整洁之道》读书笔记
### 第四章、 结构化编程 	
* 结构化编程给人的感觉就像是我们本来就是使用这样的原则在编程，有点像1+1=2一样，是因为我们目前的编程语言都遵循了这样的原则已经去掉了对无限制goto的支持，所以我们从学习语言之初就是使用这样的原则，所以习以为常。


####起源
* 证明编写程序的正确性，寻找证明程序正确的方法。
#### 1. 推导证明法
	* Dijkstra想使用数学推导的方式对程序进行推导证明，但是在研究中发现goto语句的某些用法会导致某些模块无法拆解成更小的、可证明的部分，导致无法向下进行。
	* goto不会导致此问题的其他用法的效果和更简单的分支结构if-then-else以及do-while循环结构是一致的。
	* Bohm和Jocopini证明了人们可以使用顺序结构，分支结构，循环结构这三种结构构造出任何程序，而无需goto语句，也就是说证明了可推导模块所需要的控制结构集与所有程序所需的控制结构集的最小集是等同的。
		
	* 根据结构化编程范式将模块递归降解拆分为可推导的单元。程序员将大型的系统设计拆分成模块和组件，再将这些模块和组件最终拆分为更小的，可证明的函数。
	* 对比我们的App也是这样，将一个程序分解成各个不同的模块，然后将不同的模块再细分，所有的模块都是有顺序，分支和循环结构组成，而没有goto语句，当然语法也不支持，哈哈。
	* 但是为每个函数都写正确的证明过程，这个工程太过复杂，甚至超过了函数本身。同时也没有几个程序员认为形式化验证是产出高质量软件的必备条件，所以这种欧几里得式的数学推导证明并没有得到广泛使用。
#### 2.科学证明法
  	*  科学理论和科学定律通常无法被证明，但是我们可以用实际案例来演示这些定律的正确性，通过高精度测量来证明当相关精度达到小数点后多少位是，被测量对象仍能一直满足这个定律。他们的特点是可被证伪，但是没有办法被证明。
   	* 测试只能展示bug的存在，并不能证明不存在bug。所以软件开发更像是一门科学研究学科，通过无法证伪来证明软件的正确性。
   	* 证伪过程只能应用于可证明的程序上，某段程序如果是不可证明的，如采用了不加限制的goto语句，那么无论写多少测试，都不能证明其正确性，因而要结构化编程要限制goto语句的使用。
   	
* 结构化编程范式最有价值的地方是，它赋予了我们创造可证伪程序单元的能力，而功能性降解拆分仍然是架构设计领域的最佳实战之一。
	
	
### 第五章、 面向对象编程
说起面向对象，一般都会不可避免的提起三个词，封装，继承，多态。

#### 封装
把一组相关联的数据或函数圈起来，使圈外面的代码只能看见部分函数，数据则完全不可见。如实际应用中类的公共函数和私有成员变量。

* 封装特性并不是面向对象编程特有的，像C语言就支持完整的封装特性。
* 一些面向对象的编程语言如C++确破坏了这种完美的封装，把部分私有的变量也会暴露出来。
* 像Swift语言已经彻底抛弃了头文件与实现文件分离的编程方式，更进一步的削弱了封装性。

综上可以说强封装性并不是面向对象的必要条件。但是面向对象编程在应用上确实会要求程序员尽量避免破坏数据的封装性。

#### 继承
继承的主要作用是让我们可以在某个作用域内对对外部定义的一组变量和函数进行覆盖。

* 在面向对象发明之前，早就有一些投机的方式实现继承，但是使用起来不像如今的继承这样的便利易用。

虽然面向对象编程在继承方面没有开创出新，但是确实在数据结构的伪装性上提供了相当程度的便利性。

#### 多态
指接口的多种不同实现方式。多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。

* 多态其实是函数指针的一种应用，面向对象编程在多态方面并没有提出任何新的概念，但是却让多态变得更安全，更便于使用。
* 用函数指针显式实现多态的问题在于函数指针的危险性，函数指针的调用依赖于一系列需要人为遵守的约定。面向对象编程语言为我们消除了人工遵守这些约定的必要，消除了这方便的危险性，使得多态的使用变得简单而且安全。

面向对象的多态使得插件式架构可以更加安全的使用。
##### 依赖翻转
高层模块对低层模块调用的控制关系与低层模块对高层模块接口在源代码上的依赖关系(或者叫继承关系)的方向是相反的，我们称之为依赖反转。

实现同样一项功能，在多态之前和之后会有不同的实现方式：

* 在安全便利的多态之前，软件的实现方式，高层模块调用低层模块的方法，控制流方向和源码依赖方向相同，都是高层模块依赖于低层模块。
* 使用多态之后，软件可以的实现方式，高层模块定义接口，低层模块实现高层模块的接口，高层模块直接调用高层模块定义的接口即可。此时控制流方向(高层->低层)和源码的依赖方向(低层->高层，即低层模块需要依赖于高层模块的接口)是相反的。

通过这种方法软件架构师可以完全控制采用了面向对象这种编程方式的系统中所有的源代码的依赖关系，而不受系统控制流的限制。

有了这些我们可以做到当某个组件源码需要修改，只需要重新部署该组件，而不需要修改其他组件的独立部署，可以将不同的组件分给不同的团队并行开发实现独立开发能力。

##### 总结:
面向对象编程对于架构师来说就是：以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。

	
##### 思考：
* 我们8系iOS APP代码种各种控件就是以这样的方式实现的，其中控件通过实现父控件(XPEViewVM)的方法和遵循一个个的协议(如赋值和取值协议)的方式来实现各种不同的控件，将控件做成可插拔式，修改某个空控件式只需要修改控件种的代码，而不需要修改其高层控件的代码，可以多个控件同时并行的开发。
* 对于这样的实现方式，对于高层接口的抽取变得很重要，如果考虑不周可能会出现仅仅改控件代码而无法解决业务问题的现象，所以对于接口的抽取要多思考，多总结。
* 这个章节的学习给我们平常使用的编程方式和编程习惯找到理论支持。
	  
	

### 第六章、函数式编程

函数式编程语言中的变量是不可变的。
 

##### 缘由：
* 所有的竞争问题，死锁问题，并发更新问题都是由可变变量导致的，如果变量永远不会被更改，那就永远不会产生这些问题了。因此函数式编程应运而生。
	
##### 事件溯源：
 * 我们只存储事务记录，不存储具体的状态，当需要具体的状态时，我们重头开始计算所有的事务即可。这个是函数式编程的一种应用。
 
如果我们忽略存储器和处理器在速度上的限制，不可变性就是可行的，否则只能在一定情况下是可行的，就目前来说函数式编程还有一定的局限性。
 
 
### 第七章、SRP:单一职责原则
也许是名字的原因，很多程序员根据 SRP 这个名字想当然地认为这个原则就是指：每个模块都应该只做一件事。

没错，后者的确也是一个设计原则，即确保一个函数只完成一个功能。我们在将大型函数重构成小函数时经常会用到这个原则，但这只是一个面向底层实现细节的设计原则，并不是 SRP 的全部。

对于SRP的描述应该是：任何一个软件模块都应该只对某一类行为者负责。

* 软件模块大部分情况下是指一个源代码文件，有些情况下是指一组紧密相关的函数和数据结构。
* 行为者指一个或多个用户和利益的相关者，这些人希望对系统的变更时相似的。

单一职责的优点：

* 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多
* 提高类的可读性，提高系统的可维护性
* 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。

有时候未必严格遵守这样的原则，如果逻辑非常简单，添加一个逻辑并不影响原有逻辑，或则添加一个不影响原来行为的新的方法也是可行的。但是要遵循：之后逻辑足够简单，才可以在代码级别上违反单一职责原则，只有类中方法数量足够少，才可以在方法级别上违反单一职责原则。

##### 思考：
* 其实行为是会变更的，也就是说需求是会变更的，当前情况下可能符合单一职责原则，当需求变更后，某个行为变得更加细化，目前的情况就会不符合单一职责原则。
* 这时候如果我们拆分原有的类，可能就太够耗时或则复杂，此时可以选择简单修改类。
* 当需求或行为细化到我们无法按控制的时候，就要对代码进行重构了。